(()=>{"use strict";const e="struct Fragment {\n    @builtin(position) Position : vec4<f32>,\n    @location(0) Color : vec4<f32>\n};\n\n@vertex\nfn vs_main(@builtin(vertex_index) v_id: u32) -> Fragment {\n\n    //pre-bake positions and colors, for now.\n    var positions = array<vec2<f32>, 3> (\n        vec2<f32>( 0.0,  0.5),\n        vec2<f32>(-0.5, -0.5),\n        vec2<f32>( 0.5, -0.5)\n    );\n\n    var colors = array<vec3<f32>, 3> (\n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0)\n    );\n\n    var output : Fragment;\n    output.Position = vec4<f32>(positions[v_id], 0.0, 1.0);\n    output.Color = vec4<f32>(colors[v_id], 1.0);\n\n    return output;\n}\n\n@fragment\nfn fs_main(@location(0) Color: vec4<f32>) -> @location(0) vec4<f32> {\n    return Color;\n}";var n,t;t=function*(){const n=document.getElementById("gfx-main");if(navigator.gpu){console.log(n);const t=yield navigator.gpu.requestAdapter(),o=yield t.requestDevice(),r=n.getContext("webgpu"),i="bgra8unorm";r.configure({device:o,format:i});const a=o.createRenderPipeline({vertex:{module:o.createShaderModule({code:e}),entryPoint:"vs_main"},fragment:{module:o.createShaderModule({code:e}),entryPoint:"fs_main",targets:[{format:i}]},primitive:{topology:"triangle-list"},layout:"auto"}),c=o.createCommandEncoder(),u=r.getCurrentTexture().createView(),s=c.beginRenderPass({colorAttachments:[{view:u,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});s.setPipeline(a),s.draw(3,1,0,0),s.end(),o.queue.submit([c.finish()])}},new((n=void 0)||(n=Promise))((function(e,o){function r(e){try{a(t.next(e))}catch(e){o(e)}}function i(e){try{a(t.throw(e))}catch(e){o(e)}}function a(t){var o;t.done?e(t.value):(o=t.value,o instanceof n?o:new n((function(e){e(o)}))).then(r,i)}a((t=t.apply(void 0,[])).next())}))})();